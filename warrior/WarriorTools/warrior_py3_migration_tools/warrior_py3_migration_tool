#!/usr/bin/env/python3

'''
Copyright 2017, Fujitsu Network Communications, Inc.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
'''

import sys
import os
import re
import ast
import time
import argparse
import subprocess
import logging
from datetime import datetime
import os
import xml.etree.ElementTree as et
import shutil
import json

class parse_json():
    """
    """

    def __init__(self, json_file):
        filepath = os.path.abspath(json_file.strip())
        with open(filepath, "r") as json_handle:
            json_doc = json.load(json_handle)
            self.keyword_repourls = json_doc.get("keyword_repositories")
            self.test_repourls = json_doc.get("testcase_repositories")
            self.output_dir = json_doc.get("output_dir")
            if not self.keyword_repourls or not self.test_repourls:
                print("keyword_repositories and testcase_repositories keys mandatory in given json file")
                exit(1)
            elif not type(self.keyword_repourls) == list and not type(self.test_repourls == list):
                print("keyword_repositories and testcase_repositories should be type of list")
                exit(1)



class Migrate_keyword_repo():

    def __init__(self, keyword_repos, testcase_repos, output_dir=None):
        self.keyword_repos_url = keyword_repos
        self.testcase_repos_url = testcase_repos
        self.warrior_framework_url = "https://github.com/warriorframework/warriorframework_py3.git"
        self.keyword_repo = "keyword_repositories"
        self.testcase_repo = "testcase_repositories"
        self.current_working_directory = os.getcwd()
        self.temp_directory_name = "conversion"
        self.keyword_repos_with_path = []
        self.keyword_repos_in_order = []
        self.keyword_repos_path = os.path.join(self.current_working_directory, self.temp_directory_name,
                                               "keyword_repositories")
        self.testcase_repos_path = os.path.join(self.current_working_directory, self.temp_directory_name,
                                                "testcase_repositories")
        self.numbers_dict = {"1": "one", "2": "two", "3": "three", "4": "four", "5": "five", "6": "six",
                             "7": "seven", "8": "eight", "9": "nine"}
        logging.basicConfig(level=logging.DEBUG, format="", filename="conversion.log")
        self.log = logging.getLogger()
        self.not_modified_statements = []
        self.output_dir = output_dir
    def add_log(self):
        for not_converted_line in self.not_modified_statements:
            self.log.info(not_converted_line)
        destination = shutil.copytree(self.keyword_repos_path, os.path.join(self.output_dir, "keyword_repositories"))

        shutil.copyfile(os.path.join(self.current_working_directory, "conversion.log"), os.path.join(self.output_dir, "conversion.log" ))
        print (destination)

    def creating_directories(self):
        if not os.path.exists(os.path.join(self.current_working_directory, self.temp_directory_name)):
            self.log.info("creating directory {}".format(self.temp_directory_name))
            os.mkdir(self.temp_directory_name)
        else:
            self.log.info("removing the existing directory {}".format(self.temp_directory_name))
            os.system("rm -rf {}".format(self.temp_directory_name))
            os.mkdir(self.temp_directory_name)
            self.log.info("creating directory {}".format(self.temp_directory_name))
        os.chdir(os.path.join(self.current_working_directory, self.temp_directory_name))
        os.mkdir(self.keyword_repo)
        os.mkdir(self.testcase_repo)
        self.cloning_the_repositories()


    def install_depen(self, dependency, dependency_name):
        """ This function checks if a dependency was installed. If not,
         then it raises an error.
        """
        counter = 0
        if dependency == "virtualenv":
            os.system("python3 -m pip install --user virtualenv")
            time.sleep(5)
        pip_cmds = ['pip3', 'install', dependency]

        try:
            self.log.info("installing " + dependency)
            sp_output = subprocess.Popen(pip_cmds, stdout=subprocess.PIPE,
                                         stderr=subprocess.PIPE, stdin=subprocess.PIPE)

            output, error = sp_output.communicate()
            output = output.decode("utf-8")

            if "Requirement already satisfied" in output or "Successfully installed GitPython" \
                    in output:
                self.log.info(" was able to install " + dependency_name)
                return True
            return_code = sp_output.returncode
            if return_code > 0:
                self.log.info(output, error)
        except IOError:
            counter = 1
            self.log.info("unable to install " + dependency_name)
        except:
            counter = 1
            self.log.info("unable to install " + dependency_name)
        if counter == 0:
            try:
                sp_output = subprocess.Popen(["pip", "show", dependency_name],
                                             stdin=subprocess.PIPE,
                                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                output = sp_output.stdout.read()
                if output == "":
                    self.log.info(dependency_name + " could not be installed!!")
                else:
                    self.log.info(dependency_name + " installation complete!")
            except:
                self.log.info("wasn't able to determine if " + dependency_name)

    def check_git_status(self):
        """
        this function is for checking the status of the git
        """
        try:
            null = open("/dev/null", "w")
            sp_output = subprocess.Popen("git", stdout=subprocess.PIPE,
                                         stderr=subprocess.PIPE,
                                         stdin=subprocess.PIPE, shell=True)
            null.close()
            output = sp_output.stdout.read()

            return True

        except OSError:
            return False

    def cloning_the_repositories(self):
        git_status = self.check_git_status()
        if git_status:
            self.log.info("Git is available proceeding further ")
        else:
            self.log.info("Git is not installed on the system. "
                       "Please install git and restart this installation.")
            sys.exit("Git is mandatory Please install it")
        dep_install_status = self.install_depen("GitPython", "git")
        if dep_install_status:
            self.log.info("Successfully installed package {}".format("GitPython"))
        else:
            self.log.info("Not able to install the package {}".format("GitPython"))
        import git

        # cloning warrior framework
        self.log.info("cloning warrior framework")
        git.Git(self.keyword_repos_path).clone(self.warrior_framework_url)
        self.log.info("warrior framework cloned successfully")
        warrior_repository_name = self.warrior_framework_url.split("/")[-1].split(".")[0]

        for keyword_url in self.keyword_repos_url:
            self.log.info("cloning keyword repository : {}".format(keyword_url))

            git.Git(self.keyword_repos_path).clone(keyword_url)
            repository_name = keyword_url.split("/")[-1].split(".")[0]

            pattern1 = r'(\d)'
            match1 = re.match(pattern1, repository_name)
            match1_flag = False
            if match1:
                existing_path = os.path.join(self.keyword_repos_path, repository_name)
                modified_path = "{}{}".format(self.numbers_dict[match1.group(1)],
                                              repository_name.split(match1.group(1))[-1])
                os.system("mv {}/ {}".format(existing_path,
                                             os.path.join(self.current_working_directory, self.temp_directory_name,
                                                          self.keyword_repo, modified_path)))
                match1_flag = True
            if match1_flag:
                self.keyword_repos_with_path.append(os.path.join(self.keyword_repos_path, modified_path))
                self.keyword_repos_in_order.append(os.path.join(self.keyword_repos_path, modified_path))
            else:
                self.keyword_repos_with_path.append(os.path.join(self.keyword_repos_path, repository_name))
                self.keyword_repos_in_order.append(os.path.join(self.keyword_repos_path, repository_name))

            self.log.info("successfully cloned keyword repository {}".format(keyword_url))
            # path = self.imp_url.split("/")[-1].split(".")[0]
        self.keyword_repos_in_order.append(os.path.join(self.keyword_repos_path, warrior_repository_name))

        for testcase_url in self.testcase_repos_url:
            self.log.info("cloning keyword repository : {}".format(testcase_url))
            git.Git(self.testcase_repos_path).clone(testcase_url)
            self.log.info("successfully cloned keyword repository {}".format(testcase_url))

        self.log.info(self.keyword_repos_in_order)

        for user_keyword_repo in self.keyword_repos_with_path:
            self.verify_import_statements(user_keyword_repo)

    #     verify = Verify_Import_Statements(self.user_repo_path)
    #     verify.verify_import_statements(self.user_repo_path)

    def check_for_statement_is_available_in_user_repo(self, line, user_repo_path):
        """
        This function will checks the statemnts are present in the user repo or not
        :param line:
        :param user_repo_path:
        :return:
        """

        # for changing the order of searching
        if self.keyword_repos_in_order[0] != user_repo_path:
            self.keyword_repos_in_order.remove(user_repo_path)
            self.keyword_repos_in_order.insert(0, user_repo_path)

        line = line.strip()
        for directory_path in self.keyword_repos_in_order:
            if line.startswith("from"):
                import_words = line.split()[1].split(".")


                abs_path = "/".join(import_words)
                if os.path.split(directory_path)[-1] == "warriorframework_py3":
                    actual_path = os.path.join(directory_path, "warrior", abs_path)
                    directory_name = "warrior"
                else:
                    actual_path = os.path.join(directory_path, abs_path)
                    directory_name = os.path.split(directory_path)[-1]

                if os.path.exists(actual_path) or os.path.exists("{}.py".format(actual_path)):
                    # print("directory name {}".format(directory_name))

                    return directory_name

            elif line.strip().startswith("import"):
                import_words = line.strip("import").strip().split(".")
                abs_path = "/".join(import_words)
                actual_path = os.path.join(directory_path, abs_path)
                directory_name = os.path.split(directory_path)[-1]
                if os.path.exists(actual_path) or os.path.exists("{}.py".format(actual_path)):
                    return directory_name

            elif "[Actions" in line:
                pattern = r"\s*package_list\s*\=\s*\[(Actions.*\.(\w+))\]"
                import pdb
                # pdb.set_trace()
                match = re.search(pattern, line)
                line = line.replace("[", r"\[")

                if match:
                    if match.group(1):
                        actual_path = os.path.join(directory_path, match.group(1).replace(".", "/"))
                        directory_name = os.path.split(directory_path)[-1]
                        if os.path.exists(actual_path) or os.path.exists("{}.py".format(actual_path)):
                            return directory_name

        return False

    def verify_import_statements(self, user_repo_path):
        """
        This function will verify the imports present in the provided repo/path
        :param user_repo_path:
        :return:
        """
        self.user_repo_path = user_repo_path
        if os.path.exists(self.user_repo_path):
            directory_name = os.path.split(self.user_repo_path)[-1]
            for root, _, files in os.walk(self.user_repo_path):
                if root.endswith(directory_name) and "__init__py" not in files:
                    cmd = "touch  {}/__init__.py".format(self.user_repo_path)
                    os.system(cmd)

                for file in files:

                    if file == "__init__.py":
                        pass
                    elif file.endswith(".py"):

                        filedesc = open(root + "/" + file, "r+")
                        file_lines = filedesc.readlines()
                        for fline in file_lines:

                            if (fline.startswith("import") or fline.startswith("from")) and "*" in fline:
                                self.not_modified_statements.append("[NotModified] as it is contain * in import statement {} {}".
                                           format(fline.strip(), file))
                            elif fline.strip() == "import Framework.Utils as Utils" or re.search(
                                    r"\s*import Framework.Utils as Utils", fline.strip()):

                                impo = "sed -i 's/import Framework.Utils as Utils/import " \
                                       "warrior.Framework.Utils as Utils/g' {}".format(
                                    root + "/" + file)
                                os.system(impo)

                            elif ("Framework" in fline or "Actions" in fline) and (
                                    fline.strip().startswith("import") or fline.strip().startswith("from")):

                                if "\r" in fline:
                                    fline = fline[:-2]
                                else:
                                    fline = fline[:-1]


                                repo_name = self.check_for_statement_is_available_in_user_repo(
                                    fline, self.user_repo_path)

                                converting_repo_name = self.user_repo_path.split("/")[-1].split(".")[0]
                                file_name = file
                                statement = fline
                                if repo_name:
                                    if fline.startswith("from"):


                                            impo = "sed -i 's/{}/from {}.{}/g' {}".format(fline, repo_name,
                                                                                          fline.split("from")[-1].lstrip(),
                                                                                          root + "/" + file)
                                            try :
                                                os.system(impo)
                                                self.log.info(
                                                    "[Modified]:::{}::{}::{}--After conversion from :: {} :::{}".format(converting_repo_name,
                                                                                                       file_name,
                                                                                                       statement, repo_name,
                                                                                                       "from {}.{}".format(
                                                                                                           repo_name,
                                                                                                           fline.split(
                                                                                                               "from")[
                                                                                                               -1].lstrip())))
                                            except:
                                                impo = "sed -i 's/{}/@@@@{}/g' {}".format(fline, fline,
                                                                                          root + "/" + file)
                                                os.system(impo)
                                                self.log.info(
                                                    "[NotModified]:::{}::{}::{}-- replaced with @@@@".format(converting_repo_name,
                                                                                             file_name,
                                                                                             statement))
                                                self.not_modified_statements.append("[NotModified]:::{}::{}::{}".format(converting_repo_name,
                                                                                             file_name,
                                                                                             statement))

                                    elif fline.startswith("import"):
                                        impo = "sed -i 's/{}/import {}.{}/g' {}".format(fline, repo_name,
                                                                                        fline.split("import")[
                                                                                            -1].lstrip(),
                                                                                        root + "/" + file)
                                        try :
                                            os.system(impo)
                                            self.log.info(
                                                "[Modified]:::{}::{}::{}--After conversion::: {}".format(converting_repo_name, file_name,
                                                                                            statement, repo_name,
                                                                                        "from {}.{}".format(repo_name,
                                                                                                            fline.split(
                                                                                                                "from")[
                                                                                                                -1].lstrip())))
                                        except:
                                            impo = "sed -i 's/{}/@@@@{}/g' {}".format(fline, fline, root + "/" + file)
                                            os.system(impo)
                                            self.log.info(
                                                "[Not Modified]:::{}::{}::{}-- replaced with @@@@".format(converting_repo_name,
                                                                                         file_name,
                                                                                         statement))
                                            self.not_modified_statements.append(
                                                "[NotModified]:::{}::{}::{}".format(
                                                    converting_repo_name,
                                                    file_name,
                                                    statement))


                                else:

                                        impo = "sed -i 's/{}/@@@@{}/g' {}".format(fline, fline, root + "/" + file)
                                        os.system(impo)
                                        self.log.info(
                                            "[NotModified]:::{}::{}::{}-- replaced with @@@@".format(converting_repo_name, file_name,
                                                                                    statement))
                                        self.not_modified_statements.append(
                                            "[NotModified]:::{}::{}::{}".format(
                                                converting_repo_name,
                                                file_name,
                                                statement))

                            elif "WarriorCore" in fline.strip():
                                import pdb
                                # pdb.set_trace()
                                converting_repo_name = self.user_repo_path.split("/")[-1].split(".")[0]
                                file_name = file
                                statement = fline.strip()

                                if fline.split(" ",1)[-1].strip().startswith("WarriorCore"):
                                    impo = "sed -i 's/{}/{} warrior.{}/g' {}".format(fline.strip(), fline.strip().split(" ", 1)[0].lstrip(), fline.strip().split(" ", 1)[-1].lstrip(), root + "/" + file)
                                    try:
                                        os.system(impo)
                                        self.log.info(
                                            "[Modified]{}::{}::{}--After conversion::: {}".format(converting_repo_name,
                                                                                        file_name,
                                                                                        statement, "warrior",
                                                                                        fline.split(" ", 1)[
                                                                                            0].lstrip()))
                                    except:
                                        impo = "sed -i 's/{}/@@@@{}/g' {}".format(fline, fline, root + "/" + file)
                                        os.system(impo)
                                        self.log.info(
                                            "[NotModified]{}::{}::{}-- replaced with @@@@".format(converting_repo_name, file_name,
                                                                                     statement))
                                        self.not_modified_statements.append(
                                            "[NotModified]:::{}::{}::{}".format(
                                                converting_repo_name,
                                                file_name,
                                                statement))
                            elif "[Actions" in fline:
                                # import pdb
                                # pdb.set_trace()
                                repo_name = self.check_for_statement_is_available_in_user_repo(
                                    fline, self.user_repo_path)

                                converting_repo_name = self.user_repo_path.split("/")[-1].split(".")[0]
                                file_name = file
                                statement = fline
                                if repo_name:
                                        import pdb
                                        #pdb.set_trace()
                                        actual_line = statement.split("[")[-1].split("]")[0]
                                        ffline = re.sub("Actions", "{}.Actions".format(
                                            repo_name), statement, 1)
                                        af = """sed -i 's/\[{}\]/\[{}.{}\]/g' {}""".format(
                                            actual_line, repo_name,actual_line,
                                            root + "/" + file)
                                        try:
                                            os.system(af)
                                            self.log.info(
                                                "[Modified]{}::{}::{}--After conversion from :: {} :::{}".format(converting_repo_name,
                                                                                                       file_name,
                                                                                                       statement, repo_name,
                                                                                                       "from {}.{}".format(
                                                                                                           repo_name,
                                                                                                           fline.split(
                                                                                                               "from")[
                                                                                                               -1].lstrip())))
                                        except:
                                            impo = "sed -i 's/{}/@@@@{}/g' {}".format(fline, fline, root + "/" + file)
                                            os.system(impo)
                                            self.log.info(
                                                "[NotModified]{}::{}::{}-- replaced with @@@@".format(converting_repo_name,
                                                                                         file_name,
                                                                                         statement))
                                            self.not_modified_statements.append(
                                                "[NotModified]:::{}::{}::{}".format(
                                                    converting_repo_name,
                                                    file_name,
                                                    statement))





        else:
            print("path not found")











class migrate_testrepo(Migrate_keyword_repo):
    """
    """

    def __init__(self, keyword_dirpath, testcase_dirpath, output_dir=None):
        """
        """
        self.keyword_dirpath = keyword_dirpath
        self.testcase_dirpath = testcase_dirpath
        self.output_dir = output_dir or os.path.join(os.getcwd(), "migrated_repositories")
        self.log  = logging.getLogger("Migrate_keyword_repo")

    def modify_testfile(self, filename, drivers_dict):
        """
        """
        tree = et.parse(filename)
        root = tree.getroot()
        steps = []
        loops = []
        if root.tag == "Testcase" or root.tag == "TestWrapper":
            self.log.info("[testfile] Adding Repo to steps in file [{}] ".format(filename))
            if root.tag == "Testcase":
                step_tags = ["Steps"]
            elif root.tag == "TestWrapper":
                step_tags = ["Setup", "Cleanup", "Debug"]
            for step_tag in step_tags:
                nodes = root.find(step_tag)
                if nodes:
                    steps.extend([node for node in nodes if node.tag == "step"])
                    loops.extend([node for node in nodes if node.tag == "Loop"])
            for loop_node in loops:
                steps.extend(loop_node.findall("step"))
        else:
            self.log.info("[Not Modified] xml file [{}] is not testcase xml, ignoring for conversion".format(filename))
        for step in steps:
            if not step.get("Repo"):
                repo = False
                driver_file = "{}.py".format(step.get("Driver"))
                for key, value in drivers_dict.items():
                    if driver_file in value:
                        repo = True
                        self.log.info("[Modified] Adding Repo [{}] to step [{}]".format(key, step.get("TS")))
                        step.set("Repo", key)
                        break
                if not repo:
                    step.set("Repo", "404")
                    self.log.info("[Needs Attention] Couldn't Add Repo to step [{}]".format(step.get("TS")))
            else:
                self.log.info("[Not Modified] Repo [{}] already found in step [{}]".format(step.get("Repo"), step.get("TS")))
        tree.write(filename)

    def get_productdrivers_info(self):
        """
        """
        drivers_dict = {}
        for key_repo in os.listdir(self.keyword_dirpath):
            if key_repo == "warriorframework_py3":
                pd_path = os.path.join(self.keyword_dirpath, key_repo, "warrior", "ProductDrivers")
            else:
                pd_path = os.path.join(self.keyword_dirpath, key_repo, "ProductDrivers")
            drivers_dict[key_repo] = os.listdir(pd_path)
        return drivers_dict

    def migrate_testcase_repositories(self):
        """
        """
        drivers_dict = self.get_productdrivers_info()
        for path, dirs, files in os.walk(self.testcase_dirpath):
            for f in files:
                filename = os.path.join(path, f)
                try:
                    self.modify_testfile(filename, drivers_dict)
                except Exception as e:
                    self.log.info("[Not Modified] file [{}] is not xml file, ignoring for conversion".format(filename))
        if os.path.exists(self.output_dir):
            shutil.rmtree(self.output_dir)
        destination = shutil.copytree(self.testcase_dirpath, self.output_dir)
        print(destination)




parse_obj = parse_json("migrate_info.json")
print(parse_obj.keyword_repourls)


m = Migrate_keyword_repo(parse_obj.keyword_repourls, parse_obj.test_repourls, parse_obj.output_dir)
m.creating_directories()


mig_obj = migrate_testrepo(m.keyword_repos_path, m.testcase_repos_path, parse_obj.output_dir)
mig_obj.migrate_testcase_repositories()
m.add_log()
# m.verify_import_statements("/home/apathapa/Documents/warriorframework_py3/warrior/WarriorTools/warrior_py3_migration_tools/conversion/keyword_repositories/kw_lseries")
